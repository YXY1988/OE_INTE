#pragma once
#include "EllipseDetection.h"
#include "YXYUtils.h" //指数积
#include "SceneGenerator.h"
#include "MarkerValidator.h"
#include "HomographyEstimation.hpp"
#include <math.h>

using namespace yxy;
using namespace ElliFit;
using namespace std;

/*从Ellipse/Ellipses计算Pose,连续帧之间pose可以优化，得找一个目标函数*/
class PoseEstimation
{
public:
	PoseEstimation();
	~PoseEstimation();
	
	float GetModelRadius() const { return m_ModelRadius; }
	void SetModelRadius(float val) { m_ModelRadius = val; }
	cv::Mat GetIntrinsic() const { return m_Intrinsic; }
	void SetIntrinsic(cv::Mat val) { m_Intrinsic = val; }
	cv::Mat GetCapImg() const { return m_CapImg; }
	void SetCapImg(cv::Mat val) { m_CapImg = val; }
	std::string GetModelName() const { return m_ModelName; }
	void SetModelName(std::string val) { m_ModelName = val; }
	SceneGenerator GetTmplGenerator() const { return m_TmplGenerator; }
	void SetTmplGenerator(SceneGenerator val) { m_TmplGenerator = val; }

public:

	//初始化模型和相机内参数信息，不要在计算过程中反复加载。pose 和 bg Img 是变数，不加载。
	void Initialize(cv::Mat & Intrinsic, string & ModelPath, float & ModelRadius, cv::Mat & ObjectTransform);
	cv::Mat GenerateTemplateImg(cv::Mat & pose);//TODO:由 pose 生成Template Img,不需要bg但是需要Intrinsic和model
	void CalCoarsePoses(vector<cv::Mat> & ellMats);//set radius,K,后用ellMats计算2个coarse pose

    //计算两个图像的 ROI 的 Error,用于SelectCandidate
	float CalImgError(const StructOfArray2di & pixelsOnTemplate, const vector<Mat> & images, const vector<Mat> & templates);
	float CalImgErrorBySSD(cv::Mat & m_CapImg, cv::Mat & m_TmplImg);
	float CalImgErrorByGF(cv::Mat & m_CapImg, cv::Mat & m_TmplImg);
	float CalImgErrorByDF(cv::Mat & m_CapImg, cv::Mat & m_TmplImg);

	//由 src 和 template roi 筛选出 error最小的pose , Mode 1 - SSD, 2 - GF, 3 - DF, 结果直接为 m_CandidatePose
	void SelectCandidatePose(vector<cv::Mat> & CoarsePoses, vector<ElliFit::Ellipse> & m_ellipses, int ErrMode=2);

	//需要实验的方法
	//Todo： 计算homography变换并分解 R,T
	void CalFinePoseByDFHomography();//用m_SrcImg,m_candidatePose,m_TemplateImg计算homo,把homo分解 r，t
	void CalFinePoseByKpsHomography();//用 HomoMatch中的方法计算 homography 并求 r,t分解
	void CalFinePoseBy3DIC(); //自己写 3D IC 的方法，git上 只有 2D IC

	//Todo:可视化计算结果（这部分考虑放Validator里去）
	void ShowARPoseResults();//Mode 3
	void ShowMethodDifference();//Mode 4

private:
	cv::Mat m_CapImg;//输入源图像,可以是普通图像，也可以是校正后的图像
	cv::Mat m_UndistortImg;
	cv::Mat m_TemplImg;//要用spscene里的yxy osg2cv函数把 synthetic img转为cv格式
	cv::Mat m_Intrinsic;//计算P要用到,可以
	string m_ModelName;//3D模型路径
	float m_ModelRadius;//3D模型直径，用于计算Coarse
	cv::Mat m_ObjectTransform;//3D模型绕自身的变换，与建模有关
	SceneGenerator m_TmplGenerator;//图像合成类
	vector<cv::Mat> m_coarsePoses;

	ElliFit::Ellipse m_CandidateEllipse;
	cv::Mat m_CandidateEllMat;
	cv::Mat m_CandidatePose;
	
	cv::Mat m_FinePose;
};

