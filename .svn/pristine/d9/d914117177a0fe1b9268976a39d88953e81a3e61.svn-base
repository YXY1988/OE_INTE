#include "PoseEstimation.h"
#include <Eigen/Dense>
#include <algorithm>
#include <opencv2/core/eigen.hpp>

PoseEstimation::PoseEstimation()
{
	m_ModelRadius = 0;
}

PoseEstimation::~PoseEstimation()
{
}

void PoseEstimation::Initialize(cv::Mat & Intrinsic, string & ModelPath, float & ModelRadius, cv::Mat & ObjectTransform)
{
	m_Intrinsic = Intrinsic;
	m_ModelName = ModelPath;
	m_ModelRadius = ModelRadius;
	m_ObjectTransform = ObjectTransform;

	m_TmplGenerator.SetUseImgBgFlag(false);
	m_TmplGenerator.SetCameraIntrinsic(Intrinsic);
	m_TmplGenerator.SetModelName(m_ModelName);
	m_TmplGenerator.SetObjectSelfTransform(m_ObjectTransform);
}

cv::Mat PoseEstimation::GenerateTemplateImg(cv::Mat & pose)
{
	cv::Mat result;
	cv::Mat OsgPoseMat = pose.t();
	m_TmplGenerator.SetPoseMat(OsgPoseMat);
	result = m_TmplGenerator.GetSyntheticImg();
	return result;
}

void PoseEstimation::CalCoarsePoses(vector<cv::Mat>& ellMats)
{
	if (ellMats.size() < 1)
	{
		cout << "No ellipse param for cal coarse pose" << endl;
		return;
	}
	if (m_ModelRadius == 0)
	{
		cout << "ModelRadius improperly set" << endl;
		return;
	}
	if (m_Intrinsic.empty())
	{
		cout << "No camera intrinsic parameter read" << endl;
		return;
	}

	cv::Mat rot_cv2osg = (cv::Mat_<double>(3, 3) <<
		1, 0, 0,
		0, -1, 0,
		0, 0, -1);
	
	cv::Mat Qone,ellMat,eig_Vector,eig_Value;
	double lmd1, lmd2, lmd3,w;
	cv::Mat Vmax, Vmin;
	cv::Mat pNorm,nCenter,tCenter;
	double p1, p2, p3;
	cv::Mat vec_P1, vec_P2;
	double dist_factor, dist;
	cv::Mat CoarsePose;
	cv::Mat rowmat = (cv::Mat_<double>(1, 4) << 0, 0, 0, 1);

	for (int i = 0;i < ellMats.size();i++)
	{
		ellMat = ellMats[i];
		Qone = rot_cv2osg.t()*m_Intrinsic.t()*ellMat*m_Intrinsic*rot_cv2osg;
		cv::eigen(Qone, eig_Value, eig_Vector);
		lmd1 = eig_Value.at<double>(2, 0);
		lmd2 = eig_Value.at<double>(1, 0);
		lmd3 = eig_Value.at<double>(0, 0);
		Vmax = (eig_Vector.row(0)).t();
		Vmin = (eig_Vector.row(2)).t();
		for (int j = 0; j < 2;j++)
		{
			if (j == 0) 
				w = 1;
			else 
				w = -1;
			pNorm = sqrt((lmd3 - lmd2) / (lmd3 - lmd1))*Vmax + w * sqrt((lmd2 - lmd1) / (lmd3 - lmd1))*Vmin;
			if (pNorm.at<double>(2, 0) < 0)
				pNorm = -pNorm;
			cv::normalize(pNorm, pNorm);
			nCenter = Qone.inv()*pNorm;
			cv::normalize(nCenter, nCenter);
			p1 = pNorm.at<double>(0, 0);
			p2 = pNorm.at<double>(1, 0);
			p3 = pNorm.at<double>(2, 0);
			vec_P1 = (cv::Mat_<double>(3, 1) << -p2,p1,0);
			cv::normalize(vec_P1, vec_P1);
			vec_P2 = (cv::Mat_<double>(3, 1) << -p3 * p1, -p2 * p3, p1*p1 + p2*p2);
			cv::normalize(vec_P2, vec_P2);
			dist_factor = sqrt(-lmd2 / lmd3 - lmd2 / lmd1 + 1);
			dist = dist_factor * m_ModelRadius;
			tCenter = dist * nCenter;
			hconcat(vec_P1, vec_P2, CoarsePose);
			hconcat(CoarsePose, pNorm, CoarsePose);
			hconcat(CoarsePose, tCenter,CoarsePose);
			vconcat(CoarsePose, rowmat, CoarsePose);
			cout << "The coarsePose " << j << " is: " << endl << CoarsePose << endl;
			m_coarsePoses.push_back(CoarsePose);
		}	
	}
}

float PoseEstimation::CalImgError(const StructOfArray2di & pixelsOnTemplate, const vector<Mat> & images, const vector<Mat> & templates)
{
	float err;
	uint nChannels(images.size());
	vector<vector<float> > templatePixelIntensities(nChannels, vector<float>(pixelsOnTemplate.size()));
	vector<Mat> imageDx(nChannels), imageDy(nChannels);

	LucasKanade optimization;

	//Eigen::MatrixXf sdImages(pixelsOnTemplate.size(), nParam);
	vector<float>  errorImage(pixelsOnTemplate.size(), 0.0);
	
	for (int iChannel = 0; iChannel < nChannels; ++iChannel)
	{
		ComputeImageDerivatives(images[iChannel], imageDx[iChannel], imageDy[iChannel]);

		for (int iPoint = 0; iPoint < pixelsOnTemplate.size(); ++iPoint)
		{
			int pos = templates[iChannel].cols* pixelsOnTemplate.y[iPoint] + pixelsOnTemplate.x[iPoint];
			templatePixelIntensities[iChannel][iPoint] = ((float*)templates[iChannel].data)[pos];
		}
	}
	for (int iChannel = 0; iChannel < images.size(); ++iChannel)
	{
		optimization.ComputeResiduals(images[iChannel], templatePixelIntensities[iChannel], pixelsOnTemplate, errorImage); 
	}
	err = optimization.ComputeResidualNorm(errorImage);
	return err;
}

float PoseEstimation::CalImgErrorBySSD(cv::Mat & m_CapImg, cv::Mat & m_TmplImg)
{
	float err_ssd=50.0;

	//UnitTest SSD params are the same of LucaskanadeVideoSSDSpeedTest() of EPFL's UnitTest
	OptimizationParameters optimizationParameters;
	optimizationParameters.resTol = 1e-5;
	optimizationParameters.pTol = 5e-5;
	optimizationParameters.maxIter = 50;
	optimizationParameters.maxIterSingleLevel = 10;
	optimizationParameters.pyramidSmoothingVariance.push_back(7);
	optimizationParameters.presmoothingVariance = 1;
	optimizationParameters.nControlPointsOnEdge = 50;
	optimizationParameters.borderThicknessHorizontal = 100;
	optimizationParameters.borderThicknessVertical = 50;
	optimizationParameters.bAdaptativeChoiceOfPoints = 0;
	optimizationParameters.bNormalizeDescriptors = 1;

	ConvertImageToFloat(m_TmplImg);
	ConvertImageToFloat(m_CapImg);
	StructOfArray2di controlPoints = CreateDenseGridOfControlPoints(m_TmplImg.cols, m_TmplImg.rows);
	
	StructOfArray2di pixelsOnTemplate = controlPoints;
	Mat grayscaleFloatTemplate = m_TmplImg;
	Mat grayscaleFloatImage = m_CapImg;

	//SSDCalibration
	vector<Mat> templateDescriptorFields, imageDescriptorFields;
	templateDescriptorFields.push_back(grayscaleFloatTemplate.clone());
	imageDescriptorFields.push_back(grayscaleFloatImage.clone());
	
	if (optimizationParameters.bNormalizeDescriptors)
	{
		NormalizeImage(templateDescriptorFields[0]);
		NormalizeImage(imageDescriptorFields[0]);
	}
	
	if (optimizationParameters.pyramidSmoothingVariance.empty())
	{
		err_ssd = CalImgError(pixelsOnTemplate, imageDescriptorFields, templateDescriptorFields);
		return err_ssd;
	}

	//PyramidMultilevelCalibration
	vector< vector<Mat> > smoothedImages(optimizationParameters.pyramidSmoothingVariance.size());
	vector< vector<Mat> > smoothedTemplates(optimizationParameters.pyramidSmoothingVariance.size());

#pragma omp parallel for
	for (int i = 0;i < optimizationParameters.pyramidSmoothingVariance.size();i++)
	{
		smoothedImages[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], imageDescriptorFields);
		smoothedTemplates[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], templateDescriptorFields);
	}

	float err_temp=50.0;
	for (int iLevel = 0;iLevel < optimizationParameters.pyramidSmoothingVariance.size();iLevel++)
	{
		if (iLevel == optimizationParameters.pyramidSmoothingVariance.size() - 1)
		{
			optimizationParameters.maxIterSingleLevel = optimizationParameters.maxIter;
		}
		cout << "Start using pyramid level no." << iLevel + 1 << endl;
		err_temp = CalImgError(pixelsOnTemplate, smoothedImages[iLevel], smoothedTemplates[iLevel]);
		if (err_ssd > err_temp)
			err_ssd = err_temp;
	}
	return err_ssd;
}

float PoseEstimation::CalImgErrorByGF(cv::Mat & m_CapImg, cv::Mat & m_TmplImg)
{
	float err_ssd = 50.0;

	//optimization parameters using GradientMagnitudeVideoTest of EPFL's Unittest
	OptimizationParameters optimizationParameters;
	optimizationParameters.resTol = 1e-5;
	optimizationParameters.pTol = 5e-5;
	optimizationParameters.maxIter = 50;
	optimizationParameters.maxIterSingleLevel = 10;
	optimizationParameters.pyramidSmoothingVariance.push_back(10);
	optimizationParameters.pyramidSmoothingVariance.push_back(5);
	optimizationParameters.presmoothingVariance = 1;
	optimizationParameters.nControlPointsOnEdge = 60;
	optimizationParameters.borderThicknessHorizontal = 100;
	optimizationParameters.borderThicknessVertical = 50;
	optimizationParameters.bAdaptativeChoiceOfPoints = 0;
	optimizationParameters.bNormalizeDescriptors = 1;

	ConvertImageToFloat(m_TmplImg);
	ConvertImageToFloat(m_CapImg);
	StructOfArray2di controlPoints = CreateGridOfControlPoints(m_TmplImg, 30, 0.0f, 0.0f);

	StructOfArray2di pixelsOnTemplate = controlPoints;
	Mat grayscaleFloatTemplate = m_TmplImg;
	Mat grayscaleFloatImage = m_CapImg;

	//GradientMagnitudeCalibration
	vector<Mat> templateDescriptorFields, imageDescriptorFields;

	ComputeGradientMagnitudeDescriptorFields(grayscaleFloatTemplate, templateDescriptorFields);
	ComputeGradientMagnitudeDescriptorFields(grayscaleFloatImage, imageDescriptorFields);
	
	if (optimizationParameters.bNormalizeDescriptors)
	{
		NormalizeImage(templateDescriptorFields[0]);
		NormalizeImage(imageDescriptorFields[0]);
	}

	//PyramidMultilevelCalibration
	vector< vector<Mat> > smoothedImages(optimizationParameters.pyramidSmoothingVariance.size());
	vector< vector<Mat> > smoothedTemplates(optimizationParameters.pyramidSmoothingVariance.size());

#pragma omp parallel for
	for (int i = 0;i < optimizationParameters.pyramidSmoothingVariance.size();i++)
	{
		smoothedImages[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], imageDescriptorFields);
		smoothedTemplates[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], templateDescriptorFields);
	}

	float err_temp = 50.0;
	for (int iLevel = 0;iLevel < optimizationParameters.pyramidSmoothingVariance.size();iLevel++)
	{
		if (iLevel == optimizationParameters.pyramidSmoothingVariance.size() - 1)
		{
			optimizationParameters.maxIterSingleLevel = optimizationParameters.maxIter;
		}
		cout << "Start using pyramid level no." << iLevel + 1 << endl;
		err_temp = CalImgError(pixelsOnTemplate, smoothedImages[iLevel], smoothedTemplates[iLevel]);
		if (err_ssd > err_temp)
			err_ssd = err_temp;
	}
	return err_ssd;
}

float PoseEstimation::CalImgErrorByDF(cv::Mat & m_CapImg, cv::Mat & m_TmplImg)
{
	float err_ssd = 50.0;
	float err_temp = 50.0;
	
	//optimization parameters using LukasKanadeVideoDescriptorFieldsSpeedTest of EPFL's Unittest
	OptimizationParameters optimizationParameters;
	optimizationParameters.resTol = 1e-5;
	optimizationParameters.pTol = 5e-5;
	optimizationParameters.maxIter = 50;
	optimizationParameters.maxIterSingleLevel = 10;
	optimizationParameters.pyramidSmoothingVariance.push_back(10);
	optimizationParameters.pyramidSmoothingVariance.push_back(5);
	optimizationParameters.presmoothingVariance = 0;
	optimizationParameters.nControlPointsOnEdge = 60;
	optimizationParameters.borderThicknessHorizontal = 100;
	optimizationParameters.borderThicknessVertical = 50;
	optimizationParameters.bAdaptativeChoiceOfPoints = 1;
	optimizationParameters.bNormalizeDescriptors = 1;

	ConvertImageToFloat(m_TmplImg);
	ConvertImageToFloat(m_CapImg);
	StructOfArray2di controlPoints;
	if(optimizationParameters.bNormalizeDescriptors = true)
		controlPoints = CreateAnisotropicGridOfControlPoints(m_TmplImg, 30, 0.0f, 0.0f);
	else
		controlPoints= CreateGridOfControlPoints(m_TmplImg, 30, 0.0f, 0.0f);

	StructOfArray2di pixelsOnTemplate = controlPoints;
	Mat grayscaleFloatTemplate = m_TmplImg;
	Mat grayscaleFloatImage = m_CapImg;

	//DescriptorFieldsCalibration
	vector<Mat> templateDescriptorFields, imageDescriptorFields;

	ComputeGradientBasedDescriptorFields(grayscaleFloatTemplate, templateDescriptorFields);
	ComputeGradientBasedDescriptorFields(grayscaleFloatImage, imageDescriptorFields);

	if (optimizationParameters.bNormalizeDescriptors)
	{
		for (uint i = 0; i < templateDescriptorFields.size(); ++i)
		{
			NormalizeImage(templateDescriptorFields[i]);
			NormalizeImage(imageDescriptorFields[i]);
		}
	}

	//PyramidMultilevelCalibration
	vector< vector<Mat> > smoothedImages(optimizationParameters.pyramidSmoothingVariance.size());
	vector< vector<Mat> > smoothedTemplates(optimizationParameters.pyramidSmoothingVariance.size());

#pragma omp parallel for
	for (int i = 0;i < optimizationParameters.pyramidSmoothingVariance.size();i++)
	{
		smoothedImages[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], imageDescriptorFields);
		smoothedTemplates[i] = SmoothDescriptorFields(optimizationParameters.pyramidSmoothingVariance[i], templateDescriptorFields);
	}

	for (int iLevel = 0;iLevel < optimizationParameters.pyramidSmoothingVariance.size();iLevel++)
	{
		if (iLevel == optimizationParameters.pyramidSmoothingVariance.size() - 1)
		{
			optimizationParameters.maxIterSingleLevel = optimizationParameters.maxIter;
		}
		cout << "Start using pyramid level no." << iLevel + 1 << endl;
		err_temp = CalImgError(pixelsOnTemplate, smoothedImages[iLevel], smoothedTemplates[iLevel]);
		if (err_ssd > err_temp)
			err_ssd = err_temp;
	}
	return err_ssd;
}

